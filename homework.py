# -*- coding: utf-8 -*-
"""homework.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17pJcTyOSRcLTZke0Ma6-L9grUkytcRXm
"""

# Parsing through the input file:
def input_fileopen():
    file =  open('input3.txt', "r")  
    file_lines = file.readlines() 
    typ = file_lines[0].strip() # The algorithm to be chosen.
    Width, Height = file_lines[1].split() # Dimensions of the map.
    X, Y = file_lines[2].split() # Co-ordinates of the nodes.
    bounds = int(file_lines[3]) # Stamina values.
    lodges = int(file_lines[4]) # Check points.
    
    X = int(X)
    Y = int(Y)
    Width = int(Width)
    Height = int(Height)
    
    destination = []
    dest_list = []
    
    for data in range(lodges):
      destination.append(file_lines[data + 5])    
      dest_list.append(file_lines[data + 5])
    
    map = [['0' for i in range(Width)] for j in range(Height)]
    
    for i in range(Height):
        map[i] = file_lines[i + 5 + lodges].split()
    
    for i in range(Height):
      for j in range(Width):
        map[i][j] = int(map[i][j])
    
    file.close()
    return typ, Width, Height, X, Y, destination, map, bounds, dest_list

# Checking the bounds of the map:
def bounds_check(element, destination):
    x, y = element   
    
    for iter in destination:
        fa, sa = iter.split()
        fa = int(fa)
        sa = int(sa)
        
        if x == fa and y == sa:
            destination.remove(iter)
            return True
    
    return False 

# Finding the checkpoints along the map:
def find_lodges(Width, Height, destination):
    coordinates = []
    length = len(destination)
    for ele in destination:
        x_axis, y_axis = ele.split()
        
        if int(x_axis) >= Width or int(y_axis) >= Height:
            coordinates.append(ele)
    
    for xy in coordinates:
        destination.remove(xy)
    
    return destination

# Finding the neighbors of each node- N, S, E, W, NW, NE, SW, SE:
def get_neighbors(Width, Height, element, map, bounds):
    # Defining the eight directions in which the skier can move:
    N = 0
    E = 0
    NE = 0
    NW = 0
    S = 0 
    W = 0
    SE = 0
    SW = 0
    x, y = element
    neighbors = []
    # Boundary checks:
    if (x - 1) != Width:
        N = 1
    if (x + 1) != Width:
        E = 1
    if (x + 1) != -1:
        NE = 1
    if (x - 1) != -1:
        NW = 1
    if (y + 1) != Height:
        S = 1
    if (y - 1) != Height:
        W = 1
    if (y + 1) != -1:
        SE = 1
    if (y - 1) != -1:
        SW = 1
    # Appending the neighboring nodes:
    if SE and S and abs(map[y + 1][x] - map[y][x]) <= bounds:
        neighbors.append((x, y + 1))
    
    if SW and W and abs(map[y - 1][x] - map[y][x]) <= bounds:
        neighbors.append((x, y - 1))
      
    if SW and W and NW and N and abs(map[y - 1][x - 1] - map[y][x]) <= bounds:
        neighbors.append((x - 1, y - 1))

    if SE and S and NW and N and abs(map[y + 1][x - 1] - map[y][x]) <= bounds:
        neighbors.append((x - 1, y + 1))

    if NW and N and abs(map[y][x - 1] - map[y][x]) <= bounds:
        neighbors.append((x - 1, y))

    if SE and S and NE and E and abs(map[y + 1][x + 1] - map[y][x]) <= bounds:
        neighbors.append((x + 1, y + 1))

    if NE and E and abs(map[y][x + 1] - map[y][x]) <= bounds:
        neighbors.append((x + 1, y))

    if SW and W and NE and E and abs(map[y - 1][x + 1] - map[y][x]) <= bounds:
        neighbors.append((x + 1, y - 1))
    
    return neighbors
'''
In BFS, each move from one cell to any of its 8 neighbors counts for a unit path cost of 1. You do
not need to worry about the elevation levels or about the fact that moving diagonally (e.g., North-
East) is actually a bit longer than moving along the North to South or East to West directions.
However, you still need to make sure the move is allowed by checking how steep the move is
(depends on the skier’s stamina) or whether a tree is involved. Therefore, any allowed move
from one cell to an adjacent cell costs 1.
'''
# Implementing the BFS algorithm:
def optimal_path_BFS(X, Y, Width, Height, map, bounds, destination, dest_list):
    destination = find_lodges(Width, Height, destination)
    queue = []
    path = {}
    parent = {}
    parent[(X, Y)] = "start"
    visited_node = [[0 for i in range(Width)] for j in range(Height)]
    visited_node[Y][X] = 1
    count_destination = len(destination)
    queue.append((X, Y))
    
    while len(queue) != 0 and count_destination != 0:
        element = queue[0]
        
        if bounds_check(element, destination):
            path[element] = parent[element]
            count_destination -= 1
            
            if count_destination == 0:
                break
        
        del(queue[0])
        neighbors = get_neighbors(Width, Height, element, map, bounds)
        
        for fn, sn in neighbors:
            
            if (fn, sn) not in queue and visited_node[sn][fn] != 1:
                visited_node[sn][fn] = 1
                queue.append((fn, sn))
                parent[(fn, sn)] = element
    
    output_file(dest_list, path, parent)

'''
When running UCS, you should compute unit path costs in 2D. Assume that cells’ center
coordinates projected to the 2D ground plane are spaced by a 2D distance of 10 North-South and
East-West. That is, a North or South or East or West move from a cell to one of its 4-connected
neighbors incurs a unit path cost of 10, while a diagonal move to a neighbor incurs a unit path
cost of 14 as an approximation to 10√𝟐 when running UCS. You still need to make sure the
move is allowed, in the same way you did for BFS.
'''
# Heuristic function for UCS:
def heuristic_func_UCS(element, cost_func, Width, Height, map, bounds):   
    cost_straight = 10 + cost_func
    cost_diagonal = 14 + cost_func
    N = 0
    E = 0
    NE = 0
    NW = 0
    S = 0 
    W = 0
    SE = 0
    SW = 0
    x, y = element
    neighbors = []
    
    if (x - 1) != Width:
        N = 1
    if (x + 1) != Width:
        E = 1
    if (x + 1) != -1:
        NE = 1
    if (x - 1) != -1:
        NW = 1
    if (y + 1) != Height:
        S = 1
    if (y - 1) != Height:
        W = 1
    if (y + 1) != -1:
        SE = 1
    if (y - 1) != -1:
        SW = 1

    if SE and S and abs(map[y + 1][x] - map[y][x]) <= bounds:
        neighbors.append([(x, y + 1), cost_straight])

    if SW and W and abs(map[y - 1][x] - map[y][x]) <= bounds:
        neighbors.append([(x, y - 1), cost_straight])

    if NW and N and SW and W and abs(map[y - 1][x - 1] - map[y][x]) <= bounds:
        neighbors.append([(x - 1, y - 1), cost_diagonal])

    if NW and N and SE and S and abs(map[y + 1][x - 1] - map[y][x]) <= bounds:
        neighbors.append([(x - 1, y + 1), cost_diagonal])

    if NW and N and abs(map[y][x - 1] - map[y][x]) <= bounds:
        neighbors.append([(x - 1, y), cost_straight])
    
    if NE and E and SE and S and abs(map[y + 1][x + 1] - map[y][x]) <= bounds:
        neighbors.append([(x + 1, y + 1), cost_diagonal])

    if NE and E and SW and W and abs(map[y - 1][x + 1] - map[y][x]) <= bounds:
        neighbors.append([(x + 1, y - 1), cost_diagonal])

    if NE and E and abs(map[y][x + 1] - map[y][x]) <= bounds:
        neighbors.append([(x + 1, y), cost_straight])              
    
    return neighbors

# Implementing the UCS algorithm:
from operator import itemgetter

def optimal_path_UCS(X, Y, Weight, Height, map, bounds, destination, lodge):
    parent = {}
    path = {}
    queue = []
    visited_node = [[0 for i in range(Weight)] for j in range(Height)]
    visited_node[Y][X] = 1
    parent[(X, Y)] = "start"
    queue.append([(X, Y), 0])
    destination = find_lodges(Weight, Height, destination)
    count_destination = len(destination)
    
    while len(queue) !=0 and count_destination != 0:
        element, cost = queue[0]
        
        if bounds_check(element, destination):
            path[element] = parent[element]
            count_destination -= 1
            
            if count_destination == 0:
                break
        
        del(queue[0])
        neighbor = heuristic_func_UCS(element, cost, Weight, Height, map, bounds)
        
        for child, end in neighbor:    
            
            if visited_node[child[1]][child[0]] == 0:
                visited_node[child[1]][child[0]] = end
                queue.append([child, end])
                parent[child] = element
                flag = 1
            else:
                
                for coordinate in queue:
                    
                    if child == coordinate[0] and end < coordinate[1]:
                        coordinate[1] = end
                        parent[child] = element
                        break
        if flag == 1:
            # Sorting the queue after finding the optimal path:
            queue.sort(key = itemgetter(1)) 
    
    output_file(lodge, path, parent)

'''
When running A*, you will have modified rules for allowed moves AND you should compute an
approximate integer unit path cost for each move according to how the elevation of the terrain
changes. We will explain these rules using elevations Ecurr (current cell elevation), Enext (potential
next cell elevation), and Eprev (previous cell elevation), as well as stamina S (given as input) and
momentum M (defined below).
Allowed moves for A*: For running A*, we modify whether a move is allowed by considering
momentum (M), that is whether we gained some speed by going down in elevation in our most
recent move. If we are currently at a cell with Ecurr, whether we are allowed to go into a cell Enext
is determined by whether our momentum M going from Eprev to Ecurr can assist us. We will define
M as follows:
M = &
max (0, 𝐸!"#$ − 𝐸%&""), (𝐸'#() − 𝐸%&"") > 0
0, (𝐸'#() − 𝐸%&"") ≤ 0
That is, when we are going down from Eprev to Ecurr and then up from Ecurr to Enext, momentum M
is > 0 and will possibly assist us in reaching cells with higher Enext elevations. If the next move is
going up in elevation (Enext > Ecurr), a move will only be allowed if (Enext <= Ecurr + S + M). For
BFS/UCS, this rule was (Enext <= Ecurr + S). M = 0 initially at the starting position. Note how in all
cases other than going down from Eprev to Ecurr and then up from Ecurr to Enext, momentum M is 0
according to the above definition. Note that momentum does not accumulate across multiple
moves. Only the latest Eprev to Ecurr are considered when computing M.
If a tree is involved, the rules to determine whether a move is allowed do not change from the
BFS/UCS cases. If you are allowed to move into a cell with a tree, it acts as land with elevation
|E| from then on.
Path cost for A*: You should also compute an approximate integer unit path cost for each move
for A*, which is now approximately 3D. The cost of a move is computed by considering both the
horizontal move distance as in the UCS case (unit cost of 10 when moving North to South or East
to West, and unit cost of 14 when moving diagonally) and the change in elevation levels of the
land. The cost C for the move is hence defined as follows:
C = (Horizontal Move Distance) + (Elevation Change Cost)
Where the Elevation Change Cost is defined as follows:
Elevation Change Cost = &
0, (𝐸'#() − 𝐸%&"") ≤ 𝑀
𝑚𝑎𝑥(0, 𝐸'#() − 𝐸%&"" − 𝑀), (𝐸'#() − 𝐸%&"") > 𝑀
Thus, intuitively, the elevation change cost is how much we are going uphill, possibly minus how
much momentum we have from going downhill on the previous move.
'''
# Heuristic function for A*:
import math

def heuristic_func_Astar(child, end):
    return math.floor((((10 * child[0]) - (10 * end[0])) ** 2 + ((10 * child[1]) - (10 * end[1])) ** 2) ** 0.5)

# Implementing the A* algorithm:
def optimal_path_Astar(X, Y, Weight, Height, parent, element, destination):
    momentum = 0
    parent = {}
    path = {}
    queue = []
    visited_node = [[0 for i in range(Weight)] for j in range(Height)]
    visited_node[Y][X] = 1
    parent[(X, Y)] = "start"
    queue.append([(X, Y), 0])
    destination = find_lodges(Weight, Height, destination)
    count_destination = len(destination)
    
    while len(queue) !=0 and count_destination != 0:
        alt = 0
        element, cost = queue[0]
        
        if bounds_check(element, destination):
            path[element] = parent[element]
            count_destination -= 1
            
            if count_destination == 0:
                break
        del(queue[0])
        neighbor = heuristic_func_UCS(element, cost, Weight, Height, map, destination)
        
        for child, end in neighbor:

            if abs(child) <= abs(end):
              alt = abs(child) - abs(end) + heuristic_func_Astar(child, end)
            else:
              momentum = max(0, abs(parent) - abs(end)) 
                              
              if max(0, abs(child) - abs(end) - momentum) <= destination:
                alt = abs(child) - abs(end) + heuristic_func_Astar(child, end) + max(0, abs(child) - abs(end) - momentum)    
            
            if visited_node[child[1]][child[0]] == 0:
                visited_node[child[1]][child[0]] = end
                queue.append([child, end])
                parent[child] = element
                flag = 1
            else:
                
                for coordinate in queue:
                    
                    if child == coordinate[0] and end < coordinate[1]:
                        coordinate[1] = end
                        parent[child] = element
                        break
        if flag == 1:
            queue.sort(key = itemgetter(1))
    
    output_file(path, parent)

# Printing the output onto a text file:
def output_file(destination, path, parent):
    file = open('output.txt', "w")
    
    for i in destination[:-1]:
        min_path=[]
        path_str_file = ""
        x, y = i.split()
        x = int(x)
        y = int(y)
        x_coordinate = x
        y_coordinate = y
        
        if (x, y) in path.keys():
            
            while parent[(x, y)] != "start":
                min_path.append(parent[(x, y)])
                x, y = parent[(x, y)]
            
            min_path.reverse()
            
            for iter, sec_iter in min_path:
                path_str_file = path_str_file + str(iter) + "," + str(sec_iter) + " "
            path_str_file = path_str_file + str(x_coordinate) + "," + str(y_coordinate)
            file.write(path_str_file + "\n")
        else:
            file.write("FAIL\n")
    
    min_path=[]
    path_str_file = ""
    last = destination[-1]
    x, y = last.split()
    x = int(x) 
    y = int(y)
    x_coordinate = x 
    y_coordinate = y
    
    if (x, y) in path.keys():
        
        while parent[(x, y)] != "start":
            min_path.append(parent[(x, y)])
            x, y = parent[(x, y)]
        
        min_path.reverse()
        
        for iter, sec_iter in min_path:
            path_str_file = path_str_file + str(iter) + "," + str(sec_iter) + " "
        path_str_file = path_str_file + str(x_coordinate) + "," + str(y_coordinate)
        file.write(path_str_file)
    else:
      file.write("FAIL")  
    file.close()

# Defining the main function and calling all the helper functions:
def main():
    typ, Weight, Height, X, Y, destination, map, bounds, dest_list = input_fileopen()
    
    if typ == "BFS":          
        optimal_path_BFS(X, Y, Weight, Height, map, bounds, destination, dest_list)    
    elif typ == "UCS":
        optimal_path_UCS(X, Y, Weight, Height, map, bounds, destination, dest_list)
    elif typ == "A*":
        optimal_path_Astar(X, Y, Weight, Height, map, bounds, destination)
    
if __name__ == '__main__':
    main()