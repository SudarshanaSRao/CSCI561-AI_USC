# -*- coding: utf-8 -*-
"""home_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IfBsj-qGO2D-ehonqH4QKFgvNBbhhj9t
"""

'''
Format for input.txt:
<QUERY>
<K = NUMBER OF GIVEN SENTENCES IN THE KNOWLEDGE BASE>
<SENTENCE 1>
…
<SENTENCE K>
The first line contains a query as one logic sentence (further detailed below). The line after contains an integer K specifying the number of sentences given for the knowledge base. The remaining K lines contain the sentences for the knowledge base, one sentence per line.
'''
# Defining the lists and variables:
implies = '=>'
implying_clauses = []
iter = 0
kb = {} # Knowledge base.
rows = 0
unification_check = {}
kb_fact = []

# Parsing the input text file:
filename = open("input.txt", 'r')
predicates = [] # Storing all the predicates.
num_sentences = 1
knowledge_base = filename.readline().strip() # Append the knoewledge base.
# Storing the queries:
queries = int(filename.readline().strip())
# Stripping the white space and/or new line character:
while num_sentences <= queries:
    predicates.append(filename.readline().strip())
    num_sentences += 1

while iter < queries:
    # Checking whether a predicate implies something:
    if implies in predicates[iter]:
        implying_clauses.append(predicates[iter] + ';')
    else:
        kb_fact.append(predicates[iter])
    iter += 1
'''
KB input format: Each sentence to be inserted into the knowledge base is written in FOL using
operators &, |, =>, and ~, with the following conventions:
1. & denotes the conjunction operator.
2. | denotes the disjunction operator.
3. => denotes the implication operator.
4. ~ denotes the negation operator.
5. No other operators besides &, |, =>, and ~ are used in the input to the knowledge base.
6. There will be NO parentheses in the input to the KB except to mark predicate arguments.
For example: Pred(x,y) is allowed, but A & (B | C) is not.
7. Variables are denoted by a single lowercase letter.
8. All predicates (such as Order(x,y) which means person x orders food item y) and constants (such as Broccoli) are case sensitive alphanumeric strings that begin with an uppercase letter.
9. Thus, when parsing words in the input to the KB, use the following conventions:
9.1. Single lowercase letter: variable. E.g.: x, y, z
9.2. First letter is uppercase and opening parenthesis follows the current word: predicate. E.g.: Order(x,y), Pred52(z)
9.3. Otherwise: constant. E.g.: Harry, Pizza123
10. Each predicate takes at least one argument (so, all predicate names are always followed by an opening parenthesis). Predicates will take at most 25 arguments. A given predicate name will not appear with different number of arguments.
11. Predicate arguments will only be variables or constants (no nested predicates).
12. There will be at most 100 sentences in the knowledge base.
13. See the sample input below for spacing patterns.
14. You can assume that the input format is exactly as it is described.
15. There will be no syntax errors in the given input.
16. The KB will be true (i.e., will not contain contradictions).
17. Note that the format we just specified is broader than both Horn form and CNF. Thus, you should first convert the given input sentences into CNF and then insert the converted sentences into your CNF KB for resolution.
'''
# Condition for unification:
for fact in kb_fact:
    start_fact = fact.index('(') + 1
    # Checking whether two or more sentences are present:
    if ',' in fact:
        begin_fact = fact[0 : start_fact - 1]
        end_fact = fact.index(',')
        # Appending the sentences which can be  unified:
        unification_check[begin_fact] = list()
        unification_check[begin_fact].append(fact[start_fact : end_fact])
        start_fact = end_fact
        end_fact = fact.index(')') # Ending the unified sentence.
        unification_check[begin_fact].append(fact[start_fact + 1 : end_fact])
    else:
        end_fact = fact.index(')')
        unification_check[fact[0 : start_fact - 1]] = list()
        unification_check[fact[0 : start_fact - 1]].append(fact[start_fact : end_fact])

# Defining a recursive function for entailment:
def fact_entailmentcheck(present_fact, not_entailed = None):
    # Returns true if the fact is entailed.
    if present_fact in kb_fact:
        return True
    # If the fact is not present in the KB, but a part of the sentence is entailed:
    elif present_fact[0 : present_fact.index('(')] in unification_check.keys():
        # Checking for a second fact:
        if present_fact.find(',') != -1:
            condition_1 = present_fact[present_fact.index('(') + 1 : present_fact.index(',')] in unification_check[present_fact[0 : present_fact.index('(')]] or not_entailed in unification_check[present_fact[0 : present_fact.index('(')]]
            
            if condition_1:
               return True
            
            else:
              return False
        
        else:
            condition_2 = present_fact[present_fact.index('(') + 1 : present_fact.index(')')] in unification_check[present_fact[0 : present_fact.index('(')]] or not_entailed in unification_check[present_fact[0 : present_fact.index('(')]] 
            
            if condition_2:
               return True
            
            else:
               return False

    # Checking whether the facts are present in the KB and is entailed:
    for k in kb.keys():
        
        if k[0 : k.index('(')] == present_fact[0 : present_fact.index('(')] and present_fact.find(',') != -1 and k.find(',') != -1:
            
            if k[k.index(',') + 1 : k.index(')')] == present_fact[present_fact.index(',') + 1 : present_fact.index(')')]:
                # Accessing the predicates:
                for items in kb[k]:
                    
                    if items.find('(x') != -1:
                        
                        if present_fact[present_fact.index('(') + 1 : present_fact.index(',')] != 'x':
                            not_entailed = present_fact[present_fact.index('(') + 1 : present_fact.index(',')]
                        
                        if fact_entailmentcheck(items, not_entailed) == True:
                            continue
                        
                        else:
                            return False
                    
                    elif items.find('(x') == -1 and present_fact.find('(x') != -1:

                        if fact_entailmentcheck(items, not_entailed) == True:
                            continue
                        
                        else:
                            return False

        elif k[0 : k.index('(')] == present_fact[0 : present_fact.index('(')] and present_fact.find(',') == -1 and k.find(',') == -1:
            # Accessing the predicates:
            for items in kb[k]:
                
                if items.find('(x') != -1 and present_fact.find('(x') == -1:
                    not_entailed = present_fact[present_fact.index('(') + 1 : present_fact.index(')')]
                  
                    if fact_entailmentcheck(items, not_entailed) == True:
                        continue
                    
                    else:
                        return False

                elif items.find('(x') != -1 and present_fact.find('(x') != -1:

                    if fact_entailmentcheck(items, not_entailed) == True:
                        continue
                    
                    else:
                        return False
            
            return False
    
    return True

# Converting the horn (atomic) form sentences into CNF:
for dict_keys in kb.keys():

    if dict_keys.find('(x') == -1:
        not_fact = True

        for dict_values in kb[dict_keys]:

            if dict_values.find('(x') == -1:
                not_fact = False

            if dict_values[0 : dict_values.index('(')] not in unification_check.keys():
                not_fact = False

        if not_fact == True:
            braces_fact = list()
            
            for dict_values in kb[dict_keys]:
                
                if dict_values[0 : dict_values.index('(')] in unification_check.keys():
                    braces_fact.append(set(unification_check[dict_values[0 : dict_values.index('(')]]))
            
            if dict_keys[0 : dict_keys.index('(')] in unification_check.keys():
                unification_check[dict_keys[0 : dict_keys.index('(')]].append(dict_keys[dict_keys.index('(') + 1 : dict_keys.index(',')])
            else:
                unification_check[dict_keys[0 : dict_keys.index('(')]] = list()
                unification_check[dict_keys[0 : dict_keys.index('(')]].append(dict_keys[dict_keys.index('(') + 1 : dict_keys.index(',')])

# Appending the results of the FOL to the knowledge base:
while rows < len(implying_clauses):
    starts_with = True
    order_start = 0 # The starting point of the impying clause.
    ele = 0
    # Accessing the indices of the start and end of clauses:
    sent_start = implying_clauses[rows].index('>')
    sent_end = implying_clauses[rows].index(';')
    predicate = implying_clauses[rows][sent_start + 1 : sent_end]
    # Checking the end of the sentence:
    while implying_clauses[rows][ele] != '>':
        
        if implying_clauses[rows][ele] == '=' or implying_clauses[rows][ele] == '&':
            order_end = ele + 1
            # Checking the start of the sentence:
            if starts_with == True:
                kb[predicate] = list()
                kb[predicate].append(implying_clauses[rows][order_start : order_end - 1]) # Appending the implication to the KB.
                starts_with = False
            else:
                kb[predicate].append(implying_clauses[rows][order_start : order_end - 1])
            # Updating the start variable.
            order_start = order_end

        ele += 1

    rows += 1

'''
Format for output.txt:
Your program should determine whether the query can be inferred from the knowledge base or
not, and write a single line to output.txt:
<ANSWER>
Each answer should be either TRUE if you can prove that the corresponding query sentence is true given the knowledge base, or FALSE if you cannot. This is a so-called “closed-world assumption” (things that cannot be proven from the KB are considered false).
'''
def true_write(file):
    
    out_file.write("TRUE")
    out_file.close()
    return out_file

def false_write(file):
    out_file = open("output.txt", 'w')
    out_file.write("FALSE")
    out_file.close()
    return out_file

out_file = open("output.txt", 'w') # Writing the output text file.

if fact_entailmentcheck(knowledge_base) == True: # Function call.
    true_write(out_file)

else:
    false_write(out_file)